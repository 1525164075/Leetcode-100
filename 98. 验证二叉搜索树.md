# [98. 验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree/)

给你一个二叉树的根节点 `root` ，判断其是否是一个有效的二叉搜索树。

**有效** 二叉搜索树定义如下：

- 节点的左子树只包含 **严格小于** 当前节点的数。
- 节点的右子树只包含 **严格大于** 当前节点的数。
- 所有左子树和右子树自身必须也是二叉搜索树。

 

**示例 1：**

![img](assets/tree1-1757989939216-1.jpg)

```
输入：root = [2,1,3]
输出：true
```

**示例 2：**

![img](assets/tree2.jpg)

```
输入：root = [5,1,4,null,null,3,6]
输出：false
解释：根节点的值是 5 ，但是右子节点的值是 4 。
```

 

**提示：**

- 树中节点数目范围在`[1, 104]` 内
- `-231 <= Node.val <= 231 - 1`



# 题解：

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isValidBST = function (root) {
    if (!root.left && !root.right) return true;
    if (root.left && !root.right) {
        return (root.val > root.left.val)
    } else if(!root.left && root.right){
        return (root.val < root.right.val)
    }else {
        return (root.val < root.right.val && root.val > root.left.val)
    }
    return isValidBST(root.left) && isValidBST(root.right);
};
```

发现不行 每次执行的当前节点永远无法同时比较父节点 自身节点 和子节点

层序遍历思路：

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isValidBST = function (root) {
    if (!root) {
        return true;
    }
    const queue = [];
    queue.push({
        node: root,
        lower: -Infinity,
        upper: Infinity
    });
    while (queue.length > 0) {
        const item = queue.shift();
        const node = item.node;
        const lower = item.lower;
        const upper = item.upper;
        if (!node) {
            continue;
        }
        if (node.val <= lower || node.val >= upper) {
            return false;
        }
        // 将左子节点及其更新后的范围加入队列
        if (node.left) {
            queue.push({
                node: node.left,
                lower: lower,       // 下界不变
                upper: node.val     // 上界更新为当前节点的值
            });
        }

        // 将右子节点及其更新后的范围加入队列
        if (node.right) {
            queue.push({
                node: node.right,
                lower: node.val,    // 下界更新为当前节点的值
                upper: upper        // 上界不变
            });
        }
    }
    return true;
};
```

