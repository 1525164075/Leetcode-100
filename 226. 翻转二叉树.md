# [226. 翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/)

给你一棵二叉树的根节点 `root` ，翻转这棵二叉树，并返回其根节点。

 

**示例 1：**

![img](assets/invert1-tree.jpg)

```
输入：root = [4,2,7,1,3,6,9]
输出：[4,7,2,9,6,3,1]
```

**示例 2：**

![img](assets/invert2-tree.jpg)

```
输入：root = [2,1,3]
输出：[2,3,1]
```

**示例 3：**

```
输入：root = []
输出：[]
```

**提示：**

- 树中节点数目范围在 `[0, 100]` 内
- `-100 <= Node.val <= 100`



# 题解：

树是一种重要的数据结构，它能很好地表示具有层级关系的数据，比如文件系统、公司组织架构或者网页的DOM结构。在 JavaScript 中，虽然没有内置的树数据类型，但我们通常使用**对象（Object）**或**数组（Array）**来模拟树的结构。

------



### 树的基本概念



在介绍具体实现之前，我们先了解一些树的基本术语：

- **根节点 (Root Node)**：树的顶端节点，一棵树只有一个根节点。
- **父节点 (Parent Node)**：一个节点的上一层节点。
- **子节点 (Child Node)**：一个节点的下一层节点。
- **兄弟节点 (Sibling Node)**：拥有相同父节点的节点。
- **叶子节点 (Leaf Node)**：没有子节点的节点。
- **边 (Edge)**：连接两个节点的线。

------



### JavaScript 中的树结构实现



在 JavaScript 中，最常见的树结构实现方式是使用嵌套的对象。每个节点都是一个对象，它包含一些表示自身信息的属性（比如 `value` 或 `name`），以及一个用于存储其子节点的属性，通常命名为 `children`。`children` 属性可以是一个数组，数组中的每个元素又是一个子节点对象。



#### 1. 基本节点结构



我们可以定义一个简单的类或构造函数来表示树的节点：

```JavaScript
class TreeNode {
  constructor(value) {
    this.value = value;
    this.children = [];
  }
}
```

使用这种方式，你可以创建一个节点并添加子节点：

```JavaScript
// 创建根节点
const root = new TreeNode('A');

// 创建子节点
const nodeB = new TreeNode('B');
const nodeC = new TreeNode('C');

// 添加子节点
root.children.push(nodeB);
root.children.push(nodeC);

// 继续添加子节点的子节点
const nodeD = new TreeNode('D');
nodeB.children.push(nodeD);

console.log(root);
```

运行上面的代码，你会得到一个看起来像这样的嵌套对象结构：

```JavaScript
TreeNode {
  value: 'A',
  children: [
    TreeNode {
      value: 'B',
      children: [
        TreeNode {
          value: 'D',
          children: []
        }
      ]
    },
    TreeNode {
      value: 'C',
      children: []
    }
  ]
}
```

这个结构清晰地展示了节点 A 有 B 和 C 两个子节点，而节点 B 又有一个子节点 D。

------



#### 2. 遍历树结构



遍历是处理树结构的核心操作。常见的遍历方式有两种：**深度优先搜索 (DFS)** 和**广度优先搜索 (BFS)**。



##### 深度优先搜索 (DFS)



DFS 沿着树的深度方向，尽可能深地访问节点，直到到达叶子节点，然后回溯。最常见的实现方式是使用**递归**。

```JavaScript
function dfs(node) {
  if (!node) {
    return;
  }
  // 访问当前节点
  console.log(node.value); 

  // 递归访问所有子节点
  for (const child of node.children) {
    dfs(child);
  }
}

// 假设我们有上面的 root 树
console.log('--- DFS 遍历结果 ---');
dfs(root); // 输出顺序: A, B, D, C
```



##### 广度优先搜索 (BFS)



BFS 从根节点开始，逐层访问所有节点。通常使用**队列 (Queue)** 来实现。

```JavaScript
function bfs(root) {
  if (!root) {
    return;
  }

  // 使用数组模拟队列
  const queue = [root];

  while (queue.length > 0) {
    // 出队
    const node = queue.shift(); 
    // 访问当前节点
    console.log(node.value);

    // 将所有子节点入队
    for (const child of node.children) {
      queue.push(child);
    }
  }
}

// 假设我们有上面的 root 树
console.log('--- BFS 遍历结果 ---');
bfs(root); // 输出顺序: A, B, C, D
```

这两种遍历方式在不同场景下各有优势。DFS 适合需要深入探索单个分支的情况，而 BFS 则适合需要按层级处理节点的情况。

希望这个介绍能帮助你理解 JavaScript 中树的基本结构和常用操作。如果想深入学习，可以尝试实现一些更复杂的树，比如**二叉树 (Binary Tree)**，它是一种特殊的树，每个节点最多只有两个子节点。

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {TreeNode}
 */
var invertTree = function(root) {
    if(!root) return null;
        const left = invertTree(root.left);
        const right = invertTree(root.right);
        root.right = left;

        
        root.left = right;
    
    

    return root;
};
```

