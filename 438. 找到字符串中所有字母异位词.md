# [438. 找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/)

给定两个字符串 `s` 和 `p`，找到 `s` 中所有 `p` 的 **异位词** 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。

 

**示例 1:**

```
输入: s = "cbaebabacd", p = "abc"
输出: [0,6]
解释:
起始索引等于 0 的子串是 "cba", 它是 "abc" 的异位词。
起始索引等于 6 的子串是 "bac", 它是 "abc" 的异位词。
```

 **示例 2:**

```
输入: s = "abab", p = "ab"
输出: [0,1,2]
解释:
起始索引等于 0 的子串是 "ab", 它是 "ab" 的异位词。
起始索引等于 1 的子串是 "ba", 它是 "ab" 的异位词。
起始索引等于 2 的子串是 "ab", 它是 "ab" 的异位词。
```

 

**提示:**

- `1 <= s.length, p.length <= 3 * 104`
- `s` 和 `p` 仅包含小写字母

# 题解:

```js
/**
 * @param {string} s
 * @param {string} p
 * @return {number[]}
 */
var findAnagrams = function (s, p) {
    const lenS = s.length;
    const lenP = p.length;

    const res = [];
    for (let i = 0; i < lenS - lenP + 1; i++) {
        let arr = []
        for (let j = 0; j < lenP; j++) {
            arr.push(s[i + j]);
        }
        if (arr.sort().join('') === p.split('').sort().join('')) {
            res.push(i);
        }
    }
    return res;
};
```

### **优化探索**

我的问题会引导你发现性能瓶颈并找到优化方向。

1. 让我们聚焦于算法的核心部分：`arr.sort().join('') === p.split('').sort().join('')`。这一行的目的是什么？它是在检查两个字符串的什么特性？

   目的是看两个字符是否为异位词

2. 除了“排序后看是否相等”之外，还有没有其他方法可以判断两个字符串是否拥有完全相同的字符和数量？（提示：异位词的核心是什么？）
   哈希表？

3. 再看看你的外层循环。当我们把考察的窗口从 `s` 的 `s[i...i+M-1]` 滑动到 `s[i+1...i+M]` 时，这两个子字符串之间有很强的关联性。你的代码每次都对一个全新的子串进行排序，这里面是否存在一些重复的、可以被优化的计算？
   应该设置窗口长度为lenP（s[i] ... s[i+lenP-1]）

```ini
输入: s = "cbaebabacd", p = "abc"
输出: [0,6]
解释:
起始索引等于 0 的子串是 "cba", 它是 "abc" 的异位词。
起始索引等于 6 的子串是 "bac", 它是 "abc" 的异位词。
```

```js
/**
 * @param {string} s
 * @param {string} p
 * @return {number[]}
 */
var findAnagrams = function (s, p) {
    const lenS = s.length;
    const lenP = p.length;
    const pMap = new Map();
    const sMap = new Map();
    const res = [];
    // p 构造哈希表
    for (let i = 0; i < lenP; i++) {
        if (pMap.has(p[i])) {
            pMap.set(p[i], pMap.get(p[i]) + 1);
        } else {
            pMap.set(p[i], 1);
        }
    }

    // s 构造窗口哈希表
    for (let i = 0; i < lenP; i++) {
        sMap.set(s[i], (sMap.get(s[i]) || 0) + 1);
    }
    let matchCount = 0;
    for (const [char, count] of pMap) {
        if (sMap.get(char) === count) {
            matchCount++;
        }
    }
    if (matchCount === pMap.size) {
        res.push(0);
    }

    // ...接在你计算完初始 matchCount 并检查完索引 0 之后

    for (let i = lenP; i < lenS; i++) {
        const charIn = s[i];
        const charOut = s[i - lenP];

        // --- 更新滑入的 charIn ---
        const requiredCountIn = pMap.get(charIn);
        // 只有当 charIn 是 p 中的字符时，才需要更新 matchCount
        if (requiredCountIn !== undefined) {
            if (sMap.get(charIn) === requiredCountIn) matchCount--; // 一个匹配即将因数量过多而被破坏
        }
        sMap.set(charIn, (sMap.get(charIn) || 0) + 1);
        if (requiredCountIn !== undefined) {
            if (sMap.get(charIn) === requiredCountIn) matchCount++; // 数量增加后，正好达成了一个新匹配
        }

        // --- 更新滑出的 charOut ---
        const requiredCountOut = pMap.get(charOut);
        // 只有当 charOut 是 p 中的字符时，才需要更新 matchCount
        if (requiredCountOut !== undefined) {
            if (sMap.get(charOut) === requiredCountOut) matchCount--; // 一个匹配即将因数量减少而被破坏
        }
        sMap.set(charOut, sMap.get(charOut) - 1);
        if (requiredCountOut !== undefined) {
            if (sMap.get(charOut) === requiredCountOut) matchCount++; // 数量减少后，正好达成了一个新匹配
        }

        // --- 检查结果 ---
        if (matchCount === pMap.size) {
            res.push(i - lenP + 1);
        }
    }
    return res;
};
```

