# [1. 两数之和](https://leetcode.cn/problems/two-sum/)

给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值** *`target`* 的那 **两个** 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。

你可以按任意顺序返回答案。

 

**示例 1：**

```
输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
```

**示例 2：**

```
输入：nums = [3,2,4], target = 6
输出：[1,2]
```

**示例 3：**

```
输入：nums = [3,3], target = 6
输出：[0,1]
```

 

**提示：**

- `2 <= nums.length <= 104`
- `-109 <= nums[i] <= 109`
- `-109 <= target <= 109`
- **只会存在一个有效答案**

 

**进阶：**你可以想出一个时间复杂度小于 `O(n2)` 的算法吗？



## 题解：

题目只存在一个有效答案 不会出现重复的两组

考虑用双指针

1. 数组从小到大排序 sort方法时间复杂度`nlogn`

```js
nums.sort()
//nums = [2,7,11,15]
```

2. 左右两个指针`left` 和 `right`

3. 同时比较`nums[left] + nums[right]` 的值 跟target比较 

```js
while(left < right){
if((nums[left] + nums[right]) == target){
    return left, right;
}
else if ((nums[left] + nums[right]) > target){
    right -= 1;
}else{
    left -= 1
}
}

```



**注意：不可以排序 因为返回的是下标** 所以双指针的方法不适用 **双指针要求有序数组**

**考虑哈希表**

1. 创建哈希表
   ```js
   const map = new Map();
   ```

2. 遍历数组 尝试把每一个数字存入哈希表 key为下标 value为nums

   哈希表**不擅长根据值来查找** **把关键信息放在key上**

   ```js
   //{2=>0, 7=>1}
   ```

3. 遍历到某个元素的时候 计算complement = target - currentNum

4. 在哈希表找到complement 若找到 则返回 否则进行下一轮遍历

   ```js
   /**
    * @param {number[]} nums
    * @param {number} target
    * @return {number[]}
    */
   var twoSum = function(nums, target) {
       const map = new Map();
       for(let i = 0; i < nums.length; i++){
           const complement = target - nums[i]
           if(map.has(complement)){
               return [map.get(complement), i]
           }
           map.set(nums[i], i)
       }
   };
   ```

   